{
    "sourceFile": "lib/features/capture/cubits/association_internal_goodsIssue_productionJobOrder/production_job_order_cubit.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1750747815768,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750930731089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -374,9 +374,9 @@\n     emit(ProductionJobOrderUpdateMappedBarcodesLoading());\n \n     final gs1CompanyPrefix = await AppPreferences.getGs1Prefix();\n     try {\n-      final results = await Future.any([\n+    await Future.any([\n         // update bom API call\n         _httpService.request(\n           \"/api/bom/${jobOrderDetail?.id}\", // sales order detail id\n           method: HttpMethod.put,\n"
                }
            ],
            "date": 1750747815767,
            "name": "Commit-0",
            "content": "import 'dart:developer';\n\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:gtrack_nartec/constants/app_preferences.dart';\nimport 'package:gtrack_nartec/constants/app_urls.dart';\nimport 'package:gtrack_nartec/controllers/epcis_controller.dart';\nimport 'package:gtrack_nartec/features/capture/cubits/association_internal_goodsIssue_productionJobOrder/production_job_order_state.dart';\nimport 'package:gtrack_nartec/features/capture/models/association_internal_goodsIssue_productionJobOrder/bin_locations_model.dart';\nimport 'package:gtrack_nartec/features/capture/models/association_internal_goodsIssue_productionJobOrder/bom_start_model.dart';\nimport 'package:gtrack_nartec/features/capture/models/association_internal_goodsIssue_productionJobOrder/mapped_barcodes_model.dart';\nimport 'package:gtrack_nartec/features/capture/models/association_internal_goodsIssue_productionJobOrder/production_job_order.dart';\nimport 'package:gtrack_nartec/features/capture/models/association_internal_goodsIssue_productionJobOrder/production_job_order_bom.dart';\nimport 'package:gtrack_nartec/features/capture/models/scan_packages/container_response_model.dart';\nimport 'package:gtrack_nartec/features/capture/models/scan_packages/pallet_response_model.dart';\nimport 'package:gtrack_nartec/features/capture/models/scan_packages/serial_response_model.dart';\nimport 'package:gtrack_nartec/features/capture/models/scan_packages/sscc_response_model.dart';\nimport 'package:gtrack_nartec/global/services/http_service.dart';\nimport 'package:gtrack_nartec/models/capture/Association/Receiving/sales_order/sub_sales_order_model.dart';\nimport 'package:gtrack_nartec/models/capture/Association/shipping/vehicle_model.dart';\n\nclass ProductionJobOrderCubit extends Cubit<ProductionJobOrderState> {\n  ProductionJobOrderCubit() : super(ProductionJobOrderInitial());\n\n  // HTTP Services\n  final HttpService _httpService = HttpService();\n  final HttpService _httpServiceForDomain = HttpService(\n    baseUrl: AppUrls.domain,\n  );\n\n  ProductionJobOrderDetail? jobOrderDetail;\n  ProductionJobOrder? order;\n  String bomStartType = 'pallet';\n  List<MappedBarcode> items = [];\n  late BomStartModel gs1Data;\n\n  List<ProductionJobOrder> filteredOrders = [];\n  List<ProductionJobOrder> _orders = [];\n  List<VehicleModel> _vehicles = [];\n  List<BinLocation> binLocations = [];\n  VehicleModel? selectedVehicle;\n  BinLocation? selectedBinLocation;\n  int quantityPicked = 0;\n  String? selectedGLN;\n\n  // Maps\n  final Map<String, List<Map>> _packagingScanResults = {};\n  final List<Map> _selectedpackagingScanResults = [];\n\n  // Getters\n  List<VehicleModel> get vehicles => _vehicles;\n  Map<String, List<Map>> get packagingScanResults => _packagingScanResults;\n  List<Map> get selectedpackagingScanResults => _selectedpackagingScanResults;\n\n  // Selected Data\n  SubSalesOrderModel? selectedSubSalesOrder;\n\n  /*\n  ##############################################################################\n  ! Packaging Scan\n  ##############################################################################\n  */\n\n  // Item selection methods\n  void toggleItemSelection(Map item) {\n    final existingIndex = _selectedpackagingScanResults.indexWhere((element) =>\n        element['serialGTIN'] == item['serialGTIN'] &&\n        element['serialNo'] == item['serialNo']);\n\n    if (existingIndex >= 0) {\n      _selectedpackagingScanResults.removeAt(existingIndex);\n      quantityPicked--;\n    } else {\n      // // If picked quantity is equal to the quantity, don't fetch mapped barcodes\n      if (quantityPicked >= (jobOrderDetail?.quantity ?? 0)) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'You have reached the maximum quantity',\n        ));\n        return;\n      }\n\n      _selectedpackagingScanResults.add(item);\n      quantityPicked++;\n    }\n    emit(PackagingSelectionChanged(selected: _selectedpackagingScanResults));\n  }\n\n  bool isItemSelected(Map item) {\n    return _selectedpackagingScanResults.any((element) =>\n        element['serialGTIN'] == item['serialGTIN'] &&\n        element['serialNo'] == item['serialNo']);\n  }\n\n  void clearSelectedItems() {\n    _selectedpackagingScanResults.clear();\n    quantityPicked = 0;\n    emit(PackagingSelectionChanged(selected: _selectedpackagingScanResults));\n  }\n\n  Future<void> getMappedBarcodes(\n    String gtin, {\n    String? palletCode,\n    String? serialNo,\n  }) async {\n    if (state is ProductionJobOrderMappedBarcodesLoading) return;\n    if (palletCode != null) {\n      if (palletCode.isEmpty) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'Pallet code is required',\n        ));\n        return;\n      }\n    } else if (serialNo != null) {\n      if (serialNo.isEmpty) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'Serial number is required',\n        ));\n        return;\n      }\n    }\n    emit(ProductionJobOrderMappedBarcodesLoading());\n    try {\n      // If picked quantity is equal to the quantity, don't fetch mapped barcodes\n      if (quantityPicked >= (jobOrderDetail?.quantity ?? 0)) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'You have reached the maximum quantity',\n        ));\n        return;\n      }\n      final token = await AppPreferences.getToken();\n      String url = '/api/mappedBarcodes?';\n      if (palletCode != null) {\n        url += 'PalletCode=$palletCode&GTIN=$gtin';\n      } else if (serialNo != null) {\n        url += 'ItemSerialNo=$serialNo&GTIN=$gtin';\n      }\n\n      final response = await _httpService.request(\n        url,\n        headers: {\n          'Authorization': 'Bearer $token',\n          'Content-Type': 'application/json',\n        },\n      );\n\n      if (response.success) {\n        final data = response.data;\n        final mappedBarcodes = MappedBarcodesResponse.fromJson(data);\n        if (mappedBarcodes.data?.isEmpty ?? true) {\n          emit(ProductionJobOrderMappedBarcodesError(\n            message: 'No mapped barcodes found for $gtin',\n          ));\n          return;\n        }\n        // add all new list but don't add duplicates\n        // final newItems = mappedBarcodes.data\n        //     ?.where((element) => !items.any((e) => e.id == element.id))\n        //     .toList();\n        final newItems = mappedBarcodes.data;\n        items.addAll(newItems ?? []);\n        // increment quantity\n        if (jobOrderDetail != null) {\n          jobOrderDetail = jobOrderDetail!.increasePickedQuantity();\n          quantityPicked++;\n        }\n\n        emit(ProductionJobOrderMappedBarcodesLoaded(\n            mappedBarcodes: mappedBarcodes));\n      } else {\n        emit(ProductionJobOrderMappedBarcodesError(\n            message: 'Failed to fetch mapped barcodes'));\n      }\n    } catch (e) {\n      emit(ProductionJobOrderMappedBarcodesError(message: e.toString()));\n    }\n  }\n\n  Future<void> scanPackagingBySscc({\n    String? palletCode,\n    String? serialNo,\n  }) async {\n    if (state is ProductionJobOrderMappedBarcodesLoading) {\n      return;\n    }\n\n    if (palletCode != null) {\n      if (palletCode.isEmpty) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'Pallet code is required',\n        ));\n        return;\n      }\n    } else if (serialNo != null) {\n      if (serialNo.isEmpty) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'Serial number is required',\n        ));\n        return;\n      }\n    }\n    emit(ProductionJobOrderMappedBarcodesLoading());\n    try {\n      final token = await AppPreferences.getToken();\n\n      // check if the ssccNo is already scanned\n      if (_packagingScanResults.containsKey(serialNo ?? palletCode)) {\n        emit(ProductionJobOrderMappedBarcodesError(\n            message: 'Packaging already scanned'));\n        return;\n      }\n\n      final path = palletCode != null\n          ? '/api/scanPackaging/sscc?ssccNo=$palletCode'\n          : '/api/ssccPackaging/details?serialNo=$serialNo&association=true';\n\n      // call the API\n      final response = await _httpService.request(\n        path,\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': 'Bearer $token',\n        },\n      );\n\n      if (response.success) {\n        // If we are scanning by pallet\n        if (palletCode != null) {\n          if (response.data['level'] == 'container') {\n            final containerData =\n                ContainerResponseModel.fromJson(response.data);\n\n            // Initialize an empty list for this ssccNo if it doesn't exist yet\n            if (!_packagingScanResults.containsKey(palletCode)) {\n              _packagingScanResults[palletCode] = [];\n            }\n\n            for (final pallet in containerData.container.pallets) {\n              for (final ssccPackage in pallet.ssccPackages) {\n                for (final detail in ssccPackage.details) {\n                  _packagingScanResults[palletCode]!.add({\n                    \"ssccNo\": ssccPackage.ssccNo,\n                    \"description\": ssccPackage.description,\n                    \"memberId\": ssccPackage.memberId,\n                    \"binLocationId\": ssccPackage.binLocationId,\n                    \"masterPackagingId\": detail.masterPackagingId,\n                    \"serialGTIN\": detail.serialGTIN,\n                    \"serialNo\": detail.serialNo,\n                  });\n                }\n              }\n            }\n          } else if (response.data['level'] == 'pallet') {\n            final palletData = PalletResponseModel.fromJson(response.data);\n\n            // Initialize an empty list for this ssccNo if it doesn't exist yet\n            if (!_packagingScanResults.containsKey(palletCode)) {\n              _packagingScanResults[palletCode] = [];\n            }\n\n            for (final pallet in palletData.pallet.ssccPackages) {\n              for (final detail in pallet.details) {\n                _packagingScanResults[palletCode]!.add({\n                  \"ssccNo\": pallet.ssccNo,\n                  \"description\": pallet.description,\n                  \"memberId\": pallet.memberId,\n                  \"binLocationId\": pallet.binLocationId,\n                  \"masterPackagingId\": detail.masterPackagingId,\n                  \"serialGTIN\": detail.serialGTIN,\n                  \"serialNo\": detail.serialNo,\n                });\n              }\n            }\n          } else if (response.data['level'] == 'sscc') {\n            final ssccData = SSCCResponseModel.fromJson(response.data);\n\n            // Initialize an empty list for this ssccNo if it doesn't exist yet\n            if (!_packagingScanResults.containsKey(palletCode)) {\n              _packagingScanResults[palletCode] = [];\n            }\n\n            for (final detail in ssccData.sscc.details) {\n              _packagingScanResults[palletCode]!.add({\n                \"ssccNo\": ssccData.sscc.ssccNo,\n                \"description\": ssccData.sscc.description,\n                \"memberId\": ssccData.sscc.memberId,\n                \"binLocationId\": ssccData.sscc.binLocationId,\n                \"masterPackagingId\": detail.masterPackagingId,\n                \"serialGTIN\": detail.serialGTIN,\n                \"serialNo\": detail.serialNo,\n              });\n            }\n          }\n        }\n\n        // If we are scanning by serial\n        else if (serialNo != null) {\n          final serialResponse = SerialResponseModel.fromJson(response.data);\n          // Initialize an empty list for this ssccNo if it doesn't exist yet\n          if (!_packagingScanResults.containsKey(serialNo)) {\n            _packagingScanResults[serialNo] = [];\n          }\n\n          for (final item in serialResponse.data.items) {\n            _packagingScanResults[serialNo]!.add({\n              \"ssccNo\": item.masterPackaging.ssccNo,\n              \"description\": item.masterPackaging.description,\n              \"memberId\": item.masterPackaging.memberId,\n              \"binLocationId\": item.masterPackaging.binLocationId,\n              \"masterPackagingId\": item.masterPackaging.id,\n              \"serialGTIN\": item.serialGTIN,\n              \"serialNo\": item.serialNo,\n            });\n          }\n        }\n\n        // Emit the loaded state with the scan results for this SSCC\n        // emit(PackagingScanLoaded(response: _packagingScanResults));\n        emit(ProductionJobOrderMappedBarcodesLoaded(\n          mappedBarcodes: _packagingScanResults,\n        ));\n      } else {\n        final errorMessage =\n            response.data?['message'] ?? 'Failed to scan packaging';\n        emit(ProductionJobOrderMappedBarcodesError(message: errorMessage));\n      }\n    } catch (error) {\n      emit(ProductionJobOrderMappedBarcodesError(message: error.toString()));\n    }\n  }\n\n  void pickSelectedItems({required String orderDetailId}) async {\n    try {\n      if (state is PickItemsLoading) {\n        return;\n      }\n\n      emit(PickItemsLoading());\n      final path = '/api/packagingPickActivity';\n      final payload = _selectedpackagingScanResults\n          .map((scannedItem) => {\n                \"contextType\": \"sales\",\n                \"contextId\": orderDetailId,\n                \"serialGTIN\": scannedItem['serialGTIN'],\n                \"serialNo\": scannedItem['serialNo'],\n                \"pickedQuantity\": \"1\",\n                \"binLocationId\": scannedItem['binLocationId'],\n                \"pickedBy\": scannedItem['memberId']\n              })\n          .toList();\n\n      log(payload.toString());\n\n      final response = await _httpService.request(\n        path,\n        method: HttpMethod.post,\n        payload: payload,\n      );\n\n      if (response.success) {\n        emit(PickItemsLoaded(message: response.data['message']));\n      } else {\n        emit(PickItemsError(message: response.data['message']));\n      }\n    } catch (e) {\n      emit(PickItemsError(message: e.toString()));\n    }\n  }\n\n  void updateMappedBarcodes(\n    String location, {\n    ProductionJobOrder? oldOrder,\n    int? qty,\n    String? gln,\n  }) async {\n    emit(ProductionJobOrderUpdateMappedBarcodesLoading());\n\n    final gs1CompanyPrefix = await AppPreferences.getGs1Prefix();\n    try {\n      final results = await Future.any([\n        // update bom API call\n        _httpService.request(\n          \"/api/bom/${jobOrderDetail?.id}\", // sales order detail id\n          method: HttpMethod.put,\n          payload: {\n            'binLocation': location,\n            'quantityPicked': \"$quantityPicked\",\n          },\n        ),\n\n        _httpService.request(\n          \"/api/workInProgress/submitPickAndCreateWIP\",\n          method: HttpMethod.post,\n          payload: {\n            'jobOrderDetailId': \"${jobOrderDetail?.jobOrderDetailsId}\",\n          },\n        ),\n        // update mapped barcodes API call\n        // _httpService.request(\n        //   \"/api/salesInvoice/master/${oldOrder?.id}\", // job order id\n        //   method: HttpMethod.put,\n        //   payload: {\n        //     'binLocationId': location,\n        //   },\n        // ),\n\n        // Then update Job Order Details\n        _httpService.request(\n          \"/api/jobOrder/details/${jobOrderDetail?.jobOrderDetailsId}\",\n          method: HttpMethod.put,\n          payload: {\n            \"binLocationId\": selectedBinLocation?.id.toString(),\n          },\n        ),\n\n        // EPCIS API Call\n        EPCISController.insertNewEPCISEvent(\n          // eventType: \"TransactionEvent\",\n          eventType: \"AssociationEvent\",\n          latitude: selectedBinLocation?.latitude?.toString(),\n          longitude: selectedBinLocation?.longitude?.toString(),\n          gln: selectedBinLocation?.gln,\n          ssccNo: selectedpackagingScanResults.first['ssccNo'],\n          bizTransactionList: [\n            {\n              \"type\": \"po\",\n              \"bizTransaction\":\n                  \"http://transaction.acme.com/jo/${jobOrderDetail?.jobOrderDetailsId}\"\n            },\n          ],\n          childEPCs: selectedpackagingScanResults\n              .map((item) =>\n                  'urn:epc:id:sscc:$gs1CompanyPrefix.${item['ssccNo']}')\n              .toList(),\n        ),\n      ]);\n\n      // // EPCIS API Call\n      // await EPCISController.insertEPCISEvent(\n      //   type: \"Transaction Event\",\n      //   action: \"ADD\",\n      //   bizStep: \"shipping\",\n      //   disposition: \"in_transit\",\n      // );\n\n      // await _httpService.request(\n      //   // \"/api/bom/${oldOrder?.jobOrderMaster?.id}\",\n      //   \"/api/bom/${bomStartData?.id}\", // jobOrderId || id\n      //   method: HttpMethod.put,\n      //   data: {\n      //     'binLocation': location,\n      //     'quantityPicked': \"$quantityPicked\",\n      //   },\n      // );\n\n      emit(ProductionJobOrderUpdateMappedBarcodesLoaded(\n        message: \"Packaging process completed\",\n        updatedCount: selectedpackagingScanResults.length,\n      ));\n    } catch (e) {\n      emit(ProductionJobOrderUpdateMappedBarcodesError(message: e.toString()));\n    }\n  }\n\n  /*\n  ##############################################################################\n  ! End\n  ##############################################################################\n  */\n\n  Future<void> getProductionJobOrders() async {\n    emit(ProductionJobOrderLoading());\n    try {\n      final memberId = await AppPreferences.getMemberId();\n      final token = await AppPreferences.getToken();\n\n      final response = await _httpService\n          .request(\"/api/jobOrder/details?memberId=$memberId\", headers: {\n        'Authorization': 'Bearer $token',\n        'Content-Type': 'application/json',\n      });\n\n      if (response.success) {\n        final List<dynamic> data = response.data;\n        final orders = data.map((e) => ProductionJobOrder.fromJson(e)).toList();\n        _orders = orders;\n        emit(ProductionJobOrderLoaded(orders: orders));\n      } else {\n        emit(ProductionJobOrderError(message: 'Failed to fetch orders'));\n      }\n    } catch (e) {\n      emit(ProductionJobOrderError(message: e.toString()));\n    }\n  }\n\n  Future<void> searchProductionJobOrders(String query) async {\n    try {\n      if (query.isEmpty) {\n        filteredOrders = _orders;\n        emit(ProductionJobOrderLoaded(orders: _orders));\n        return;\n      }\n      final orders = _orders.where((element) {\n        return element.jobOrderMaster?.jobOrderNumber\n                ?.toLowerCase()\n                .contains(query.toLowerCase()) ??\n            false;\n      }).toList();\n      filteredOrders = orders;\n      emit(ProductionJobOrderLoaded(orders: orders));\n    } catch (e) {\n      emit(ProductionJobOrderError(message: e.toString()));\n    }\n  }\n\n  Future<void> getProductionJobOrderBom(String jobOrderDetailsId) async {\n    emit(ProductionJobOrderBomLoading());\n    try {\n      final token = await AppPreferences.getToken();\n      final response = await _httpService\n          .request(\"/api/bom?jobOrderDetailsId=$jobOrderDetailsId\", headers: {\n        'Authorization': 'Bearer $token',\n        'Content-Type': 'application/json',\n      });\n\n      if (response.success) {\n        final List<dynamic> data = response.data;\n        final bomItems =\n            data.map((e) => ProductionJobOrderDetail.fromJson(e)).toList();\n        emit(ProductionJobOrderBomLoaded(bomItems: bomItems));\n      } else {\n        emit(ProductionJobOrderBomError(message: 'Failed to fetch BOM items'));\n      }\n    } catch (e) {\n      emit(ProductionJobOrderBomError(message: e.toString()));\n    }\n  }\n\n  Future<void> getBomStartDetails(String barcode) async {\n    emit(ProductionJobOrderBomStartLoading());\n    try {\n      final token = await AppPreferences.getToken();\n\n      final response = await _httpServiceForDomain.request(\n        \"/api/products/paginatedProducts?page=1&pageSize=10&barcode=$barcode\",\n        method: HttpMethod.get,\n        headers: {\n          'Authorization': 'Bearer $token',\n          'Content-Type': 'application/json',\n        },\n      );\n\n      if (response.success) {\n        final data = response.data;\n        if (data['products']?.isNotEmpty ?? false) {\n          gs1Data = BomStartModel.fromJson(data['products'][0]);\n          emit(ProductionJobOrderBomStartLoaded(bomStartData: gs1Data));\n        } else {\n          gs1Data = BomStartModel();\n          emit(ProductionJobOrderBomStartError(\n              message: 'Product Details not found for $barcode'));\n        }\n      } else {\n        emit(ProductionJobOrderBomStartError(\n            message: 'Failed to fetch product details'));\n      }\n    } catch (e) {\n      emit(ProductionJobOrderBomStartError(message: e.toString()));\n    }\n  }\n\n  Future<void> getBinLocations() async {\n    emit(ProductionJobOrderBinLocationsLoading());\n    try {\n      final memberId = await AppPreferences.getMemberId();\n      final token = await AppPreferences.getToken();\n\n      // final url = \"/api/mappedBarcodes/getlocationsByGTIN?GTIN=$gtin\";\n      final url = \"/api/binLocation?memberId=$memberId\";\n\n      final response = await _httpService.request(\n        url,\n        headers: {\n          'Authorization': 'Bearer $token',\n          'Content-Type': 'application/json',\n        },\n      );\n\n      if (response.success) {\n        final data = response.data as List;\n        final binLocations = data.map((e) => BinLocation.fromJson(e)).toList();\n        this.binLocations = binLocations;\n\n        emit(ProductionJobOrderBinLocationsLoaded(binLocations: binLocations));\n      } else {\n        emit(ProductionJobOrderBinLocationsError(\n            message: 'Failed to fetch bin locations'));\n      }\n    } catch (e) {\n      emit(ProductionJobOrderBinLocationsError(message: e.toString()));\n    }\n  }\n\n  Future<void> getMappedBarcodesByVehicle(\n    String gtin, {\n    String? palletCode,\n    String? serialNo,\n  }) async {\n    if (state is ProductionJobOrderMappedBarcodesLoading) return;\n    if (palletCode != null) {\n      if (palletCode.isEmpty) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'Pallet code is required',\n        ));\n        return;\n      }\n    } else if (serialNo != null) {\n      if (serialNo.isEmpty) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'Serial number is required',\n        ));\n        return;\n      }\n    }\n    emit(ProductionJobOrderMappedBarcodesLoading());\n    try {\n      // If picked quantity is equal to the quantity, don't fetch mapped barcodes\n      if (quantityPicked >= (selectedSubSalesOrder?.quantity ?? 0)) {\n        emit(ProductionJobOrderMappedBarcodesError(\n          message: 'You have reached the maximum quantity',\n        ));\n        return;\n      }\n      final token = await AppPreferences.getToken();\n      String url = '/api/mappedBarcodes?';\n      if (palletCode != null) {\n        url += 'PalletCode=$palletCode&GTIN=$gtin';\n      } else if (serialNo != null) {\n        url += 'ItemSerialNo=$serialNo&GTIN=$gtin';\n      }\n\n      final response = await _httpService.request(\n        url,\n        headers: {\n          'Authorization': 'Bearer $token',\n          'Content-Type': 'application/json',\n        },\n      );\n\n      if (response.success) {\n        final data = response.data;\n        final mappedBarcodes = MappedBarcodesResponse.fromJson(data);\n        if (mappedBarcodes.data?.isEmpty ?? true) {\n          emit(ProductionJobOrderMappedBarcodesError(\n            message: 'No mapped barcodes found for $gtin',\n          ));\n          return;\n        }\n        // add all new list but don't add duplicates\n        // final newItems = mappedBarcodes.data\n        //     ?.where((element) => !items.any((e) => e.id == element.id))\n        //     .toList();\n        final newItems = mappedBarcodes.data;\n        items.addAll(newItems ?? []);\n        // increment quantity\n        if (selectedSubSalesOrder != null) {\n          selectedSubSalesOrder =\n              selectedSubSalesOrder?.increasePickedQuantity();\n          quantityPicked++;\n        }\n\n        emit(ProductionJobOrderMappedBarcodesLoaded(\n            mappedBarcodes: mappedBarcodes));\n      } else {\n        emit(ProductionJobOrderMappedBarcodesError(\n            message: 'Failed to fetch mapped barcodes'));\n      }\n    } catch (e) {\n      emit(ProductionJobOrderMappedBarcodesError(message: e.toString()));\n    }\n  }\n\n  void updateMappedBarcodesByVehicle(\n    String location,\n    List<MappedBarcode> scannedItems, {\n    int? qty,\n  }) async {\n    emit(ProductionJobOrderUpdateMappedBarcodesLoading());\n\n    try {\n      final itemIds = scannedItems.map((item) => item.id).toList();\n\n      final response = await _httpService.request(\n        \"/api/mappedBarcodes/updateBinLocationForMappedBarcodes\",\n        method: HttpMethod.put,\n        payload: {\n          'ids': itemIds,\n          'newBinLocation': location,\n        },\n      );\n\n      await Future.any([\n        // EPCIS API Call\n        // EPCISController.insertEPCISEvent(\n        //   type: \"Transaction Event\",\n        //   action: \"ADD\",\n        //   bizStep: \"shipping\",\n        //   disposition: \"in_transit\",\n        //   gln: selectedVehicle?.glnIdNumber,\n        // ),\n\n        EPCISController.insertNewEPCISEvent(\n          eventType: \"TransactionEvent\",\n          latitude: selectedBinLocation?.latitude?.toString(),\n          longitude: selectedBinLocation?.longitude?.toString(),\n          gln: selectedBinLocation?.gln?.toString(),\n        ),\n\n        // update mapped barcodes API call\n        _httpService.request(\n          \"/api/salesInvoice/details/${selectedSubSalesOrder?.id}\",\n          method: HttpMethod.put,\n          payload: {\n            'quantityPicked': qty,\n            'vehicleId': selectedVehicle?.id.toString(),\n          },\n        ).catchError((error) {\n          throw Exception(error.data['message'] ??\n              error.data['error'] ??\n              'Failed to update mapped barcodes');\n        }),\n      ]);\n\n      if (response.success) {\n        final data = response.data;\n        emit(ProductionJobOrderUpdateMappedBarcodesLoaded(\n          message: data['message'],\n          updatedCount: data['updatedCount'],\n        ));\n      } else {\n        throw Exception('Failed to update mapped barcodes');\n      }\n    } catch (e) {\n      emit(ProductionJobOrderUpdateMappedBarcodesError(message: e.toString()));\n    }\n  }\n\n  void clearItems() {\n    items = [];\n    quantityPicked = 0;\n    emit(ProductionJobOrderMappedBarcodesLoaded(\n      mappedBarcodes: MappedBarcodesResponse(\n        data: items,\n        message: \"All items cleared successfully\",\n      ),\n    ));\n  }\n\n  void removeItem(MappedBarcode item) {\n    items.remove(item);\n    emit(ProductionJobOrderMappedBarcodesLoaded(\n      mappedBarcodes: MappedBarcodesResponse(\n          data: items, message: \"Item removed successfully\"),\n    ));\n  }\n\n  /*\n  ##############################################################################\n  ! Sales Order\n  ##############################################################################\n  */\n\n  Future<void> getVehicles() async {\n    emit(VehiclesLoading());\n    try {\n      final token = await AppPreferences.getToken();\n      final memberId = await AppPreferences.getMemberId();\n\n      if (memberId == null) {\n        throw Exception(\"Member ID not found\");\n      }\n\n      final response = await _httpService.request(\n        '/api/vehicle?member_id=$memberId',\n        method: HttpMethod.get,\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': 'Bearer $token',\n        },\n      );\n\n      if (response.success) {\n        final List<dynamic> data = response.data;\n        _vehicles = data.map((e) => VehicleModel.fromJson(e)).toList();\n        emit(VehiclesLoaded(vehicles: _vehicles));\n      } else {\n        emit(VehiclesError(message: response.message));\n      }\n    } catch (error) {\n      emit(VehiclesError(message: error.toString()));\n    }\n  }\n\n  void setSelectedVehicle(VehicleModel vehicle) {\n    selectedVehicle = vehicle;\n    emit(VehiclesLoaded(vehicles: _vehicles));\n    emit(ProductionJobOrderMappedBarcodesLoaded(\n      mappedBarcodes: MappedBarcodesResponse(\n        data: items,\n        message: null,\n      ),\n    ));\n  }\n\n  void clearAll() {\n    items = [];\n    quantityPicked = 0;\n    // selectedSubSalesOrder?.quantityPicked = 0;\n    emit(ProductionJobOrderMappedBarcodesLoaded(\n      mappedBarcodes: MappedBarcodesResponse(data: items),\n    ));\n  }\n}\n"
        }
    ]
}